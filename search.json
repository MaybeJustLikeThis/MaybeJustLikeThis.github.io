[{"title":"2024年度总结","url":"/2025/01/27/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","content":"\n”世界上只有一种真正的英雄主义，那就是在认清生活真相之后依然热爱生活。“ ————罗曼罗兰《米开朗基罗传》\n\n时光匆匆，转瞬之间已是20的年纪，对于2024年，这一年有许许多多的难以忘怀的事情，大二-大三的变化，没有大一的青涩，也没有大三大四的需要为未来考虑，是人生少有的为自己而活的短暂时光，在年关将至的今天，想着是该写点什么来纪念自己的20岁，于是有了这篇内容。\n春天写点什么总要有一些依据吧，但是本人记性又不是太好，幸好iPhone的相册记录了时间，在看到第一张照相时就有种时空回溯的感觉，记忆涌上心头，那是一张五人合照，是在24年的元旦当天，这一天非常有趣，在当天帮一个朋友表白之后，我们五条单身狗（doge）走在回学校路上感慨万千，临时起意去通宵玩桌游，现在想来是多么有趣的时光！\n然后还有当时在数港学习的工位照片，现在还记得大家都离开之后我依然在工位上刷着lc的链表题，外面天黑，安静学习的感觉是那么美好。\n之后就放寒假过年，与亲朋好友过年，24年的过年伴随着一场又一场的大雪，瑞雪兆丰年吧，24年我觉得是很有意义的一年。\n开学还给书院招了下一届的生，与老师沟通调解一些矛盾，这会已经有些风声书院要被取代，只能说这个时候大家斗争的精神还是很充足的。\n夏天孟夏，这段时光在保持学习的同时和同学们到处吃吃喝喝，还写了个周围好吃的的总结，就是嘴比较馋，到处约饭，还和朋友约着一起去了人生第一次漫展，现在想起来我还是很社恐（感觉大家都很光鲜亮丽）\n对了还和好朋友们一起去了五台山看日出，印象中这应该是我第一次看日出吧，那天很冷，条件也很恶劣，但是现在想起来的只有当天大家一起经历的美好，\n仲夏，日子照样在一天天过去，每天都在按部就班的学习课程，学习前端，然后就是吃吃吃吃吃吃吃 之后就是学习，最终面试到了北京的一家公司做实习生，个人感觉虽然没有学到多么高深的知识，但是学会了很多东西：协作流程，自己租房，自己一个人生活，什么事情都是自己干，这些珍贵的社会经验；\n除了实习之外，还和在北京一起实习的好朋友们 一起夜骑40公里去看升旗，去看天安门，在晚上 金碧辉煌的天安门城楼让我印象深刻；但是我这个人有点奇怪的爱好：在很多关键时刻我不喜欢去观看事件本身，我更喜欢看别人在这一刻的反应；我通过其他人震撼的表情，我再去看夜间的天安门城楼，心中不禁为天安门城楼添加上了一丝神性，多少革命前辈的英魂环绕其上，熠熠生辉。\n秋天到了9月，记忆中就是在学校远程实习了一个月，然后买了今年新加的电子产品：apple watch S9（刚买S9，S10就出了呜呜），虽然感觉没什么用，但是就是很喜欢美丽废物，感觉更像是一个装饰品。\n10月份主要处理了书院的事务，书院有了大的变动，也要对下一届进行一些事务上的交代，之后还组织大家进行了团建；\n冬天11月 12月 基本上就是按部就班的学习，生活，偶尔和舍友出去玩 ，其中和舍友说走就走去了天津，我只能说虽然有些许遗憾，但是果然旅游这种事情就不会无趣，天津真的是很美的城市！\n1月份就是期末考试紧张的复习，和准备面试相关的东西，之后经过面试，也是成功去快手实习了，为我的2024年画上一个完美的句号。看似我的2024很平凡，但其实很多美好的瞬间都藏在日常生活中不经意的小细节中，只有全身心投入生活，才能体会到其中真谛；\n2025年希望我能身体健康，拿到属于自己心仪的offer！\n","categories":["杂谈"],"tags":["杂谈"]},{"title":"H5唤起app实现方案调研","url":"/2024/08/20/H5%E5%94%A4%E8%B5%B7app%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/","content":"H5唤起app因为手机的原因，为了保护个人隐私信息，所以如何在保护个人隐私信息的情况下进行使用app，是H5和app开发者的关注点\n智能手机应用了名为沙盒的机制，应用只能访问它声明可能访问的资源。但沙盒也阻碍了应用间合理的信息共享，某种程度上限制了应用的能力。\n因此我们需要一种工具去实现应用通信， URL Scheme 就是这个工具。\nURL Scheme是什么组成\n[scheme:][//authority][path][?query][#fragment]｜\t\t\t\t\t\t\t\t\t\t\t\t｜\t\t\t\t｜应用标识\t\t\t\t\t\t\t\t\t行为\t\t参数\n\n比如说， 我们拿 https://www.baidu.com 来举例，scheme 自然就是 https 了。\n就像给服务器资源分配一个URL一样，以便我们去访问它一样，我们同样也可以给手机APP分配一个特殊格式的 URL，用来访问这个APP或者这个APP中的某个功能(来实现通信)。APP得有一个标识，好让我们可以定位到它，它就是 URL 的 Scheme 部分。\n常用APP的 URL Scheme\n\n\nAPP\n微信\n支付宝\n淘宝\n微博\nQQ\n知乎\n短信\n\n\n\nURL Scheme\nweixin:&#x2F;&#x2F;\nalipay:&#x2F;&#x2F;\ntaobao:&#x2F;&#x2F;\nsinaweibo:&#x2F;&#x2F;\nmqq:&#x2F;&#x2F;\nzhihu:&#x2F;&#x2F;\nsms:&#x2F;&#x2F;\n\n\nIntent安卓的原生谷歌浏览器自从 chrome25 版本开始对于唤端功能做了一些变化，URL Scheme 无法再启动Android应用。 例如，通过 iframe 指向 weixin://，即使用户安装了微信也无法打开。所以，APP需要实现谷歌官方提供的 intent: 语法\nIntent 语法intent:   HOST/URI-path // Optional host    #Intent;       package=[string];       action=[string];       category=[string];       component=[string];       scheme=[string];    end;\n\n如果用户未安装 APP，则会跳转到系统默认商店。当然，如果你想要指定一个唤起失败的跳转地址，添加下面的字符串在 end; 前就可以了:\nS.browser_fallback_url=[encoded_full_url]","categories":["前端"],"tags":["方案调研","前端"]},{"title":"6月20日有感","url":"/2025/07/03/6%E6%9C%8820%E6%97%A5%E6%9C%89%E6%84%9F/","content":"6月20日有感\n”存在先于本质。“ ————让-保罗·萨特\n\n好长时间没有写博客了，最近都在忙于学校的课设考试，忙里偷闲，包括在工作中学习，在学习中工作，除了身体很累都还是不错的，感情方面也在向好的方向发展，但是在不断的忙碌中，不知是激素调节还是什么原因,终归 是对生活的意义有了一定的质疑,突然我发现 : “我不知道生活的意义是什么.”\n我认为这是多年的应试教育带来的问题,在学校的环境下,多年的”老师教,学生学”的模式导致了如果你在人生路上没有一个清晰的目标的话,你会陷入迷茫:”你想活出怎么样的人生?”.是学习网络上的四处旅游,亲近大自然?还是说想要发大财,去学习理财,去创业?亦或者只想找一份稳定的工作,安逸的度过平凡的一生?\n你想成为什么样的人按下不谈,我也难以理解，但是我知道我想要什么，我想要的东西有很多:我喜欢音乐,我想要玩音乐,成为一名混音师;我喜欢看小说,我喜欢阅读,我想要成为一名书推人;我想要玩摄影,我想要成为一名摄影师;我还喜欢骑行,我也想试着成为一名骑行者;最后我还是一名程序员,我喜欢Coding,喜欢用代码为大家带来更好的生活.最近读到了一本书:原子习惯(Atomic Habit),里面有一句话,意思大抵是 “你的习惯构成了你的身份,构成了你”,其实我更想说:”我首先存在,然后我的喜好,我的厌恶,我的行为才构成了我”。\n所以有时候思考这么多有什么用呢，其实生活终归还是柴米油盐，但是“人是会思考的芦苇”，我觉得这句话说的非常好：人是脆弱的，是会左右摇摆的，但特殊之处就在于人会思考，如果人放弃了思考，那可就成为了真正的芦苇了。\n接下来应该也会继续坚持写作的习惯吧。\n","categories":["杂谈"],"tags":["杂谈"]},{"title":"react学习日记(三期)","url":"/2024/09/12/react%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0(%E4%B8%89)/","content":"","categories":["前端"],"tags":["前端","react","笔记"]},{"title":"react学习日记(二期)","url":"/2024/09/12/react%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0(%E4%BA%8C%E6%9C%9F)/","content":"","categories":["前端"],"tags":["前端","react","笔记"]},{"title":"ts笔记（三期）","url":"/2024/09/02/ts%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%E6%9C%9F%EF%BC%89/","content":"枚举类型数字枚举例如 红绿蓝 Red &#x3D; 0 Green &#x3D; 1 Blue&#x3D; 2 分别代表红色0 绿色为1 蓝色为2\nenum Types&#123;   Red,   Green,   BLue&#125;\n这样写就可以实现应为ts定义的枚举中的每一个组员默认都是从0开始的所以也就是\nenum Types&#123;   Red = 0,   Green = 1,   BLue = 2&#125;//默认就是从0开始的 可以不写值\n增长枚举\nenum Types&#123;   Red = 1,   Green,   BLue&#125;\n如上，我们定义了一个数字枚举， Red使用初始化为 1。 其余的成员会从 1开始自动增长。 换句话说， Type.Red的值为 1， Green为 2， Blue为 3。\n字符串枚举字符串枚举的概念很简单。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\nenum Types&#123;   Red = &#x27;red&#x27;,   Green = &#x27;green&#x27;,   BLue = &#x27;blue&#x27;&#125;\n\n由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息，字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。\n异构枚举枚举可以混合字符串和数字成员\nenum Types&#123;   No = &quot;No&quot;,   Yes = 1,&#125;\n接口枚举定义一个枚举Types 定义一个接口A 他有一个属性red 值为Types.yyds\n声明对象的时候要遵循这个规则\nenum Types &#123;   yyds,   dddd&#125;interface A &#123;   red:Types.yyds&#125; let obj:A = &#123;   red:Types.yyds&#125;\nconst枚举let  和 var 都是不允许的声明只能使用const\n大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。 常量枚举通过在枚举上使用 const修饰符来定义\nconst 声明的枚举会被编译成常量\n普通声明的枚举编译完后是个对象\nconst enum Types&#123;   No = &quot;No&quot;,   Yes = 1,&#125;\nConst 声明编译之后\n 普通声明编译之后\n反向映射它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）\n要注意的是 不会为字符串枚举成员生成反向映射。\nenum Enum &#123;   fall&#125;let a = Enum.fall;console.log(a); //0let nameOfA = Enum[a]; console.log(nameOfA); //fall\n\n原文地址：https://xiaoman.blog.csdn.net/article/details/122380754\n类型推论与类型别名当我声明了一个变量但是没有定义类型，ts会自己推测出一个类型，这就是类型推论\n如果你只有声明了，但是没有赋值，ts会推测出是一个any类型 \n定义类型别名type str =（stringlet s:str = &quot;111&quot;;consloe.log(s);\n定义函数别名type str = ()=&gt;string;let s:str = () = &gt;&quot;111&quot;;consloe.log(s);\n定义联合类型别名type str = string | number  let s: str = 123 let s2: str = &#x27;123&#x27; console.log(s,s2);\n定义值的别名type value = boolean | 0 | &#x27;213&#x27;  let s:value = true//变量s的值  只能是上面value定义的值\n\ntype 和 interface 还是一些区别的 虽然都可以定义类型1.interface可以继承  type 只能通过 &amp; 交叉类型合并\n2.type 可以定义 联合类型 和 可以使用一些操作符 interface不行\n3.interface 遇到重名的会合并 type 不行\ntype高级用法左边的值会作为右边值的子类型遵循图中上下的包含关系\ntype a = 1 extends number ? 1 : 0 //1 type a = 1 extends Number ? 1 : 0 //1 type a = 1 extends Object ? 1 : 0 //1 type a = 1 extends any ? 1 : 0 //1 type a = 1 extends unknow ? 1 : 0 //1 type a = 1 extends never ? 1 : 0 //0\n\n","categories":["前端"],"tags":["前端","笔记","ts"]},{"title":"react学习日记","url":"/2024/09/04/react%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","content":"前记之前大二暑假时候学过react18,不过是class类型的,最近在工作中遇到了用react重构的需求,现在捡起来重新学一下最新的react18用函数类型（没有需求没有动力）\n不多说,上代码：\n// app.jsximport React, &#123; useState &#125; from &quot;react&quot;;export default function App() &#123;//定义主组件  const [advice, setAdvice] = useState(&quot;&quot;);  const [count, setCount] = useState(&quot;&quot;);  async function getAdvice(params) &#123;    const res = await fetch(&quot;url&quot;);    const data = await res.json();    setAdvice(data.slip.advice);    setCount((c) =&gt; c + 1);  &#125;  useEffect(() =&gt; &#123;    //定义useEffect进行初始化,useEffect 钩子在组件挂载时调用getAdvice函数,以获取初始的建议数据。空数组[]作为第二个参数,确保该副作用只在组件挂载时执行一次。    getAdvice();  &#125;, []);  return (    &lt;div&gt;      &lt;h1&gt;&#123;advice&#125;&lt;/h1&gt;      &lt;button onclick=&#123;getAdvice&#125;&gt;Get advice&lt;/button&gt;      &lt;Message count=&#123;count&#125;&gt;&lt;/Message&gt;    &lt;/div&gt;  );&#125;function Message(props) &#123;//简单的函数组件  return (    &lt;p&gt;      you have read &lt;strong&gt;&#123;props.count&#125;&lt;/strong&gt; pieces of advice    &lt;/p&gt;  );&#125;\n基本语法jsx基本语法\n变量绑定\n在html标签中使用{},内可绑定字符串,数字,数组（基本类型）,html元素,三元表达式, API调用\n\n\n插值语法如果非要展示对象类型的话,使用JSON.stringfy();\n事件绑定 驼峰 onClick ,如果需要传参数使用高阶函数,不需要直接就传函数体\n如使用泛型,他会把泛型理解成一个dom,纠正泛型\n绑定class需要用className,多个class 需要 模版字面量 中间间隔空格 ,id就正常\n添加html片段  &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: value &#125;&#125;&gt;&lt;/div&gt;\n遍历dom   &#123;    arr.map((item) =&gt; &#123;        return &lt;div&gt;&#123;item&#125;&lt;/div&gt;    &#125;)&#125;\n条件渲染&#123;   flag ? &lt;div&gt;真的&lt;/div&gt; : &lt;div&gt;假的&lt;/div&gt;&#125;\n\nuseEffect(effect, dependencies)\neffect：一个函数,包含你想要执行的副作用代码。\ndependencies：一个数组,包含依赖项。当数组中的任何一个值发生变化时,effect 函数会重新执行。如果传入一个空数组 [],effect 函数只会在组件挂载和卸载时执行。\n\n","categories":["前端"],"tags":["前端","react","笔记"]},{"title":"ts笔记（一期）","url":"/2024/08/21/ts%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%E6%9C%9F%EF%BC%89/","content":"ts标识符的类型推导let 进行类型推导,推导出来的通用类型const 进行类型推导,推导出来的字面量类型\nlet message = &quot;aaaa&quot;;//message 已经被推断为了 字符串类型\n\nts 的数据类型数组明确的指定 数组的 类型注解\n在 ts 中 数组中一般存放相同类型的数据\n\n第一种写法 string[ ];\n第二种 Array 泛型\n\n函数函数 要求传入值最好确定类型 返回值可以进行类型推断\nfunction sum(num1: number, num2: number): number &#123;  return num1 + num2;&#125;\n\n在 TypeScript 中，你可以使用函数类型来定义函数的类型和结构。函数类型可以很灵活地定义参数和返回值的类型，这对于编写类型安全的代码非常有用。\n以下是一些函数类型的示例：\n定义函数类型\n// 定义一个函数类型，接受两个参数并返回一个 number 类型的值type MyFunctionType = (a: number, b: number) =&gt; number;// 使用定义好的函数类型来声明一个变量let myFunction: MyFunctionType = (x, y) =&gt; x + y;\n\n函数类型作为参数\n// 定义一个接受函数类型作为参数的函数function executeOperation(operation: (a: number, b: number) =&gt; number, x: number, y: number): number &#123;return operation(x, y);&#125;// 调用函数，传入具体的函数作为参数let result = executeOperation((a, b) =&gt; a \\* b, 3, 4); // result 的值为 12\n\n可选参数和默认参数函数类型也可以包含可选参数和默认参数：\ntype ConcatenateStrings = (a: string, b?: string) =&gt; string;let concat: ConcatenateStrings = (str1, str2 = &quot; World&quot;) =&gt; str1 + str2;console.log(concat(&quot;Hello&quot;)); // 输出 &quot;Hello World&quot;console.log(concat(&quot;Hello&quot;, &quot; Fitten&quot;)); // 输出 &quot;Hello Fitten&quot;\n\n剩余参数函数类型还可以使用剩余参数：\ntype JoinStrings = (...str: string[]) =&gt; string;let join: JoinStrings = (...str) =&gt; str.join(&quot; &quot;);console.log(join(&quot;Hello&quot;, &quot;Fitten&quot;, &quot;Code&quot;)); // 输出 &quot;Hello Fitten Code&quot;\n\nunknown 类型在 TypeScript 或 JavaScript 中，”unknown” 是一种类型，它表示一个值可以是任何类型。与 “any” 类型不同的是，”unknown” 类型更为严格，因为它会强制你在使用它之前进行类型检查或类型断言。\n以下是一个简单的示例，展示了如何使用 “unknown” 类型：\nfunction doSomething(value: unknown) &#123;  if (typeof value === &quot;string&quot;) &#123;    //类型缩小    console.log(value.toUpperCase());  &#125; else if (typeof value === &quot;number&quot;) &#123;    console.log(value.toFixed(2));  &#125; else &#123;    console.log(&quot;Unsupported type&quot;);  &#125;&#125;let myVar: unknown = &quot;Hello&quot;;doSomething(myVar); // 输出 &quot;HELLO&quot;myVar = 42;doSomething(myVar); // 输出 &quot;42.00&quot;\n\nvoid 类型在 TypeScript 或 JavaScript 中，”void” 是一种特殊的类型，用来表示函数没有返回值。如果一个函数不返回任何值，它的返回类型通常会被标记为 “void”。\n以下是一个简单的示例，展示了如何使用 “void” 类型：\nfunction greet(): void &#123;  console.log(&quot;Hello there!&quot;);&#125;function calculateSum(a: number, b: number): void &#123;  let result = a + b;  console.log(&quot;The sum is: &quot; + result);&#125;\n\n在这个示例中，我们定义了两个函数 greet 和 calculateSum，它们的返回类型都被标记为 “void”，因为它们并不返回任何值。\nnever类型开发中很少定义never类型 ，开发框架时候可能会用到never类型;\n封装类型工具时可能用到\n给同事看的 ,在扩展工具时 对其他case直接报错\n","categories":["前端"],"tags":["前端","笔记","ts"]},{"title":"ts笔记（二期）","url":"/2024/08/21/ts%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E6%9C%9F%EF%BC%89/","content":"tsClass下面是一个简易的vue用class写的\ninterface Options &#123;    el: string | HTMLElement&#125;interface VueCls&#123;options :optionsinit():void&#125;interface Vnode&#123;    tag:string    text?:string    children?.Vnode[]&#125;// 虚拟domclass Dom&#123;    //创建节点的节点    createElement(el:string )&#123;        return document.createElement(el)    &#125;    //填充文本的方法    setText(el:HTMLElement,text:string | null)&#123;        el.textContent = text;    &#125;    render(data:Vnode)&#123;        let root = this.createElement(data.tag)        if(data.chlidren &amp;&amp; Array.isArray(data.children))&#123;            data.children.forEach((item)=&gt;&#123;                let child =   this.render(item);              root.appendChild(child)            &#125;)        &#125;else&#123;          this.setText(root,data.text)         &#125;        return root    &#125;&#125;class Vue extends Dom implements VueCls&#123;    options:Options    constructor(options:Options)&#123;        super();        this.options = options;    &#125;    init():void&#123;        let data:Vnode =&#123;            tag:&quot;div&quot;,            children:[                &#123;                    tag:&quot;section&quot;,                    text:&quot;子节点一&quot;                &#125;,                &#123;                    tag:&quot;section&quot;,                    text:&quot;子节点二&quot;                &#125;            ]        &#125;        let app = typeof this.options.el == &#x27;string&#x27; ?  document.querySelector(this.options.el) : this.option.el;        app.appendChild(this.render(data));           &#125;&#125;\n\n抽象类抽象类是面向对象编程中的一个重要概念，主要用于定义一组接口和共享的行为，同时不提供具体实现。以下是关于抽象类的一些要点和示例：\n\n定义抽象类: 不能被实例化的类，通常包含一个或多个抽象方法（没有具体实现）。目的: 强制子类实现某些方法，并提供基本的共享功能。\n特性可以包含具体方法（有实现）和抽象方法（无实现）。子类必须实现所有的抽象方法，除非子类也是抽象类。\n\n","categories":["前端"],"tags":["前端","笔记","ts"]},{"title":"ts笔记（四期）","url":"/2024/09/09/ts%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%E6%9C%9F%EF%BC%89/","content":"Symbol自ECMAScript 2015起，symbol成为了一种新的原生类型，就像number和string一样。symbol类型的值是通过Symbol构造函数创建的。\n可以传递参做为唯一标识 只支持 string 和 number类型的参数\n使用symbol定义的属性，是不能通过如下方式遍历拿到的const symbol1 = Symbol(&#x27;666&#x27;)const symbol2 = Symbol(&#x27;777&#x27;)const obj1= &#123;   [symbol1]: &#x27;小满&#x27;,   [symbol2]: &#x27;二蛋&#x27;,   age: 19,   sex: &#x27;女&#x27;&#125;// 1 for in 遍历for (const key in obj1) &#123;   // 注意在console看key,是不是没有遍历到symbol1   console.log(key)&#125;// 2 Object.keys 遍历Object.keys(obj1)console.log(Object.keys(obj1))// 3 getOwnPropertyNamesconsole.log(Object.getOwnPropertyNames(obj1))// 4 JSON.stringfyconsole.log(JSON.stringify(obj1))\n可以通过以下两种方法拿到：\n// 1 拿到具体的symbol 属性,对象中有几个就会拿到几个Object.getOwnPropertySymbols(obj1);console.log(Object.getOwnPropertySymbols(obj1));// 2 es6 的 Reflect 拿到对象的所有属性Reflect.ownKeys(obj1);console.log(Reflect.ownKeys(obj1));\n\n迭代器和生成器支持遍历大部分类型迭代器 arr nodeList argumetns set map 等\nvar arr = [1,2,3,4];let iterator = arr[Symbol.iterator](); console.log(iterator.next());  //&#123; value: 1, done: false &#125;console.log(iterator.next());  //&#123; value: 2, done: false &#125;console.log(iterator.next());  //&#123; value: 3, done: false &#125;console.log(iterator.next());  //&#123; value: 4, done: false &#125;console.log(iterator.next());  //&#123; value: undefined, done: true &#125;\n\ninterface Item &#123;    age: number,    name: string&#125; const array: Array&lt;Item&gt; = [&#123; age: 123, name: &quot;1&quot; &#125;, &#123; age: 123, name: &quot;2&quot; &#125;, &#123; age: 123, name: &quot;3&quot; &#125;] type mapTypes = string | numberconst map:Map&lt;mapTypes,mapTypes&gt; = new Map() map.set(&#x27;1&#x27;,&#x27;王爷&#x27;)map.set(&#x27;2&#x27;,&#x27;陆北&#x27;) const obj = &#123;    aaa:123,    bbb:456&#125; let set:Set&lt;number&gt; = new Set([1,2,3,4,5,6])// let it:Iterator&lt;Item&gt; = array[Symbol.iterator]()const gen = (erg:any): void =&gt; &#123;    let it: Iterator&lt;any&gt; = erg[Symbol.iterator]()    let next:any= &#123; done: false &#125;    while (!next.done) &#123;        next =  it.next()        if (!next.done) &#123;            console.log(next.value)        &#125;    &#125;&#125;gen(array)\n语法糖平时开发中最常用的就是for of\nfor (let value of map) &#123;    console.log(value)&#125;\n数组解构的原理其实也是调用迭代器\nvar [a,b,c] = [1,2,3] var x = [...xxxx]\n那我们可以自己实现一个迭代器让对象支持for or\n const obj = &#123;    max: 5,    current: 0,    [Symbol.iterator]() &#123;        return &#123;            max: this.max,            current: this.current,            next() &#123;                if (this.current == this.max) &#123;                    return &#123;                        value: undefined,                        done: true                    &#125;                &#125; else &#123;                    return &#123;                        value: this.current++,                        done: false                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;console.log([...obj]) for (let val of obj) &#123;   console.log(val);   &#125;\n\n\n","categories":["前端"],"tags":["前端","笔记","ts"]},{"title":"正确与不正确之谈","url":"/2024/10/27/%E4%BA%8C%E5%8D%81%E4%B8%80%E4%B8%96%E7%BA%AA%E7%97%85%E7%90%86/","content":"最近国内娱乐圈的一些事情，让我不禁感慨，当下的人们变了，在2015年左右，大家对于一件事情的评价，往往更依赖于“权威”，可以是专家，可以是前辈，或者是大佬。但是近几年，大家开始变得讨厌权威，或者说讨厌对于一件事情去评价他的绝对正确与错误，因为每个人都觉得自己是正确的，都有自己的理念，或者说，大家本就不是一个“圈子”里的人，往往自己做一些事情时都会带上自己的圈子里的一些潜规则，自然而然，就认为自己是对的。\n这也导致了现在人们都开始讨厌一些“爹味”重的角色，因为“爹味”难免会有权威的影子，现在大家追求的是“自我价值”，而不是“权威”。这导致一个点————“正确”与“不正确”的界限变得模糊，甚至变得不那么重要了，“正确”开始消失了。\n各个圈子的分化越来越严重，前段时间的乙游事件，其实就是一个圈子和其他圈子的对撞，各个圈子里肯定会有冲突的地方，但是没人觉得自己是错误的，因为我只是在做“自己”罢了，之前几年，可能大家都知道有些规则，这些规则就在那里，自己如果做错了，多少会有自省，但是如果现在所有人都对呢？\n现在即使不正确，也会是“不正确”的“正确”，这就让原来坚持正确的人成了傻子，书写正确的人，多多少少会散发一些“爹味”，因为他想指导你，指导你什么是正确，可悲，现在的人只能用一些虚无缥缈的东西去抒发自己，没有人敢坚定的抒发自己心中的正确，因为你的“正确”，在别人眼里不一定正确，反而会遭到有心人士的攻击。这些人无法在发表任何Real的东西的时候，可能纯粹的人就少了一点吧。。。\n","categories":["杂谈"],"tags":["杂谈"]},{"title":"开奖后有感","url":"/2025/11/11/%E5%BC%80%E5%A5%96%E5%90%8E%E6%9C%89%E6%84%9F/","content":"秋招后闲谈\n盛年不重来，一日难再晨。及时当勉励，岁月不待人。——陶渊明  \n\n2025年11月10号，也是感觉算是人生一个小里程碑了吧，毕竟算是人生第一份工作了，对于我这样的学历背景来说，也是没什么好不满意的了。\n但是心中百味杂陈，今天正好是我告别Rain离开北京的一天，北京的风带上了伤感的意味，在意识到 我签了这份协议，明年就成为一名在社会层面上的“人”了，不是学生，不是会被社会保护的身份，就像雏鹰第一次被逼下悬崖——我可能算是拥有了在社会上翱翔的资格。我庆幸于自己早日的觉醒，早日的为了自己的职业生涯而努力，也庆幸在努力的过程中遇到了我的初恋，这样一想似乎已经是一个不错的结果了，我是说，你知道的朋友，毕竟生活中没那么多英雄主义。\n也许我曾经也幻想过自己可能会成为一个名人，一个对社会做出杰出贡献的人，科学家，运动员，或者是一名杰出的作曲家，但是很显然 我并没有做到这些，我选择入职美团也是因为我赞同美团的理念，“让大家吃的更好，穿的更好”。这样给我一种 我也为了社会的大众做出了一些力所能及的贡献？让大家及时的吃饱饭？哈哈，民以食为天嘛。\n我现在在绿皮火车上。去北京时为了更快的见到Rain，坐了高铁，在回去时，追求速度也无甚意义。不得不说，火车和高铁确实是有很多不同的，记得去时的高铁上，坐在我旁边的女士，正是要去北京找比较好的医院去做人流（女士在我旁边打的电话，不是故意听的），正忧愁于术后的痛苦，但是她的丈夫似乎并未陪同。而在火车上，情况就比较复杂了：铺天盖地的行李，大包小包，充满着气味的食物，还见到了许多背着比自己大一倍还要多行李的中老年女士，蹒跚前行，她们会从不知道哪个包里掏出一个水果小口的吃着，她们也不理解为什么16:40开的火车16:00就开始检票了，担心为什么这么长时间火车都不开，于是找我反复确认了火车班次……\n大家生活是不同的，互联网害了很多人，人类社会还在遵循着最基本的自然守则，世界就是一个草台班子。其实我意识到了我想要的生活是什么样子的，但是我被裹挟了，的的确确被裹挟了，但是又无法改变，改变，改变会带来春天的浪潮，谁又不想看到春天来呢……\n附一张雍和宫口拍的银杏树：\n","categories":["杂谈"],"tags":["杂谈"]},{"title":"体质挽救计划","url":"/2025/11/23/%E4%BD%93%E8%B4%A8%E6%8C%BD%E6%95%91%E8%AE%A1%E5%88%92/","content":"\n  93db3f059e7806b2ceba7b1e1ea727883b2bf933d0205abf599403d4fb751032baf4ee2389a767488b4f365955df12398dab1f934a1b342f99695f424c09156f5473605d1db5ad4df48e571d5f02b92bed68644067108f0c5070f9e93827ca6e80977c70d9156354927b56fe479fb4bc53eecd7b368fee81cdad21d054868881322591ee1baa4e193ef22a35861c5bfd879433fe8676bf586ea1d715f52e737a772e67b1bc0940219d4554b38df208470b03d8facefde550a411de3fd0861f6070f46ead18d30f8b8b8a6c2b7110f650765c4ea039b9f5b4b5c3453607c6b264e5de2544fc718cef7c6df92df45000a76267fa7d44d957ae09502dcaeb9931dfcf3d58e4dbb497395366d9f28a02b50f417efeca70e46afe4cdafafcd7618edd1925c22a7e2476ef6d9d9c6dbfae93e37e42516d7f989accf90971d1d72ce4ece14fb86c3ea1741151651d254e234b7e57c2d9dbc15a91c6c700c7bb5d0258a7ca1e9334323bd9954bd06b60ab20ea18ffbcd63948d3c889086f9dee1a45ee9d9928da4221fb67b35747c011e56a06e7a9c7b3c7f74d762bbdd33027da07540adb08bfe2ae139fba9988fcd4bcbcead6c49b33653f659206a2198702f9839e7d8f350633797cef9d50ffb6c61e172f50dc94f7aad70537a7835874be355ff8d2c16cc3fdf523b07327b112d9584a3c4983562c5d801cde3426d8ba27d6f0016fdd68ad706703ba2bfde3001d2756c0f31df5665c6680f5d0a20d4f7925630d4d268e061800d442d0bd2743a6df32e3745655a954f60ed5c3e372420cc8539acc502ae90df76b987e60f2411812b44622a356bc6a017b2e159bd38af3072222846f4322c4eb4dc4122c046f936f599c4d6f1b4ab4414642380dfa0426f15a73804a36b6b9945111162aaf298b9b5e16f67661c43e4cc6840c21b6618ba6ac062d59353c7529407e130c46dbc63b5d4b18597913ec8c2aa87b497319d962b756495dc991b21e09012f306785c316f05a0f30b049f382636a63e4afb80d8f8767ea30080e0a50587595bdfd577fa79439842b367c250f309b059d1d21fbb20e6f0ba6183396800b9af3b03dae56f0adbd773e5d4d7f74037326a085ba9cc3d31bc7b06dbb0dda06f77b8879e71cdd78acb3323d2a3569457730a6b78b41fb36a4defea79c6a2c7129516d58fc596b24cff85673bb5898c79b8dd189800fec4f10a9339f1bbd6e0f04fc585bd8e221748e1f3d7de5a8628d76317905db14574aa3209589fa91a5cf51b04863da6cb1e4cd4ca0fcd3138a268a31894423406c57ce333b7b34a45b548bcdd36a1883866306c8e1c9675f88c7026c38200c71b4d474d0787f9ff42dc46f5b9a37af648c846d2f989929b568374456fd49e431edf8cc0d404626b38efdfe6853a3ffcee0df8db6f341912b52949bf4e8c0f52d3d1d2da34dd0d2171492ce4f09c9c37b2b5b1cfb93a920b30506fe86cb565982d99405f7e77b166feaf498a5e68c35cf8641237f721f8908d922a5d1b48c71ee32d80f9a0195b08f42c8b900d5844fa52d7ce2d8ec7f0b7874f2864748e5e037cc6f84c2bcd646b82c4edde062ca3da69666cb2ad632895075d5a29d780961794bfc21563281efa869d2d7a88e4479908f602ff78ac1cd39132db6f2d51b78c0a74a7015a1fadeea0dd67670d4470a39ab042392331ebdc85761769f32ddda220d6f079b7cd0379416e9abbe07ae12cc4f3329feb05b09c07bd4289544b95eab1fa6a7e953a95bd969eba9a73d1180bc5f07d8b514f8c270caf02ad6f68389b828cb83c15ac3e4d29ba4516a9bd33783a93d82e714661fb76c3d3080187021460f0644f97f1ce33b88c96e9486e2c9321fad2094323849d870bdbe13c6fc3f042fc1075afe91acc72198c00c6f7c15a5364789c668558573f0f0c6be404205c8799589ecf0dd715d625acbe7cd9cff7b32a98b35bec404fd2d316e6341d1c06c1689123d0bd3cd8f7d417ad2c40ed4fb2d4fb0757225a85b369887f12ef800b21358af270faff164bde0be11721a66aba63b933486785959d45da6d864eca96a9f1f171e831f91a9f6a09fafec81fdb7f5eef2798373936a941e8411556530a8229761993f9846f2dbb7a568955fba4da7c444f3fd0fbdbb0cfe9ef3dd58c0c4c39ff8d5b3b6ebcde6111ba53d9007da4230637a939ad4cee04cfb164304e2f7c8aad027773009b7441bb43be738f2604a6aabe90d2550343f3b32f305e3283b07861310284143aa0d8b5723184304410f772649299afb1a3de96d86f383daac3c742803ff51a5320a54497ddaacfb3007b35f317e228a5b1d226f03b9011406aefe7234777b0d0beb4f8fc71803a4d568d26cfb18b0b302396b19bccb3c4ded52264345bbbb099656440b73c65ba9f24510370326ac24adfcf3f20bf1ae62cfd1197ee72ff7ead1f70a9aa2ca0d46365e0eee56de9d4c5d4f63f63fdcf2e196b3f801c571b74b0f4346142504ca6c8f1f8186cf34e19cb151d450792a89d87eaed440d15bf14b210633c7b0fa74d76fbdac91ef7eae3d189416c7b1f606304d348cc573f26c1fd6f9c28f720dc0ee09b0a21bc261e3a438c0f16ea03da336581fde823e7047de4bdd8df8244d8e3edd388cdc9d22161bde7f042ac27751d7296f5752b0ca1069b035018df5806e05e45c7af3e6f7596f8a32047ecfba3b59b2d01cd3ac6d8af79a74a58c1aeea78787371f182f76bc9e36c0fe8501bff999395dfa2b6543de8c375f5dbb2a737b8540bf90a51c643ad1a4a92d0be8752aa59a6a443d1037b10aa010cc35a62d1d8693ba214f8b2690ef2fb35c0688319e81f7cb1492ccbedc90401b375ae05ea9bbb65e986d25ea12e91252459fa54b5cd8062bd9205784b428399da91737aa9e5ca391509ac4466a7b4b03f6bb10731851cf92095b9a81a6e777c97786bdb3b82d4e17ec05900b6f3b1e8be3b8c669ae0363d604de9af6a1e14edbff37e5bad1b69986606ec34ba1ab4b0ea589b79e6d8750d2e7bd8189f71178b86b2a7161a9078e2233c6330eb8470de83bab68d25b0c3e08150991b377d3a3e881d8517c38c866665f457e1ad15a94581230266071db0679f53786962b0a13f572c9eccec0cbe3d92805b2f534bb31138e89f675ffbeca7e210b841d9cf32c9ad84ed502839434796f3fd269688530ea724ccb53acf89d944f09311791663178ffa96873ebba33c00fcbff608224ccf4bdccf432f17ad58caf12d4d44d3edd3f9114c7dd7e4bf403e31db94f54b4c771ed3c850d95284398be5cf851d95d75ae629f19bc0656f96da21f7259282f73405f87f5992f265ef3616b8858b286af9a4ec9fd53fd2dafabd8c5609c8cadd3ef28b9827b5c7488b2e04d17b958ecde52b3ceeebd1cf980c609fbd2c32d983eb6f941faf8bd0221024e4a87bde13907a8258d8d1232af12b09cf6d36c1e451c54eb9f35a705fc75291dad48569c8c40cb1d4727af206b748364dfd2d23429cfd2ec7a0e493d19561c01bcd21aaf16b1e2548679fc4c2d50388ad2fd66e04b7042d19360dfff9c1e595fb047eb94a72b74b2c494e76d84a67cddc0ce84c68eb752761c0046f0ba26627726fa\n  \n    \n      \n      \n        您好, 这里需要密码.\n      \n      \n        \n      \n    \n  \n\n","categories":["Rain"],"tags":["Rain"]},{"title":"北京实习杂谈","url":"/2024/08/19/%E5%8C%97%E4%BA%AC%E5%AE%9E%E4%B9%A0%E6%9D%82%E8%B0%88/","content":"不知觉的，我已经来到北京独自生活月余了，大家都说，北京是一座能提升幸福感的城市，确实如此，来到过北京后，去哪个城市都很幸福。QAQ\n城市映像北京给我的第一感受，下了高铁之后的，扑面而来的感受 就是热，没错，7月份来到北京，给我最直观的感受就是热。北京的热不像是山西的热，山西的热你是可以暂避其锋芒的，而北京的热，非要形容的话，似是恶毒的泼皮蛮不讲理地燥热你的内心，炎热你的身体，使你汗流浃背，相比之下，山西的热最多算顽皮的小孩了。\n在经过令人眩晕的热度之后，再仔细端详这座城市，他是如此低调，低调到我一度认为来到了某个县城，并没有想象中整洁宽广的大道，有的是不那么平整的街道；没有想象中街边行人光鲜亮丽的衣着，有的是许多不修边幅，疲惫之色溢于言表的过客；没有大城市的喧闹，有的是一种沉默的死寂，和同学走在路上，与同学们嬉笑的声音，仿佛是黑白画幅里的油彩，与这座城市格格不入，在那一刻我就知道，对于这座城市，我注定是过客。\n之后在北京也算是游玩了不少地方，北京的知名景点也是去了不少，给我印象最深刻的还是天安门城楼:\n\n\n（原谅我菜鸡的拍摄技巧）\n城楼有一股能让人安静下来的气场，使人安静下来，平和心态，主席的画像如此和蔼，使人感慨新中国成立的几十年风风雨雨，可能这就是历史的厚重感吧。\n实习随笔第一次来到这个规模不大不小的公司，说不紧张是假的，还好有个同行的伙伴一起，来到公司，也并没有我想象中的严格的工作要求，大家更像是比较有分寸的朋友，都保持了最基本的社交礼仪，在一起商量着推进项目，给我的感觉还是很友善的。\n令人感到悲哀的是，北京有许许多多厉害的人物，985 211遍地走，各种有能力的大佬，使我大开眼界，只能说不愧华夏不愧四万万人民，各种各样的人才辈出，（老家的初中同学去参加巴黎奥运会了，震惊我100年），又深切体会到自己的菜，而在北京这个现实的城市中，难免又会胡思乱想，自己的前程似乎也走向了未知的地步…\n可能我有点悲观了，但我似乎并不是一个悲观的人，是确切有东西改变了我的，是什么呢？我站在路口发问，可能回答我的只有秋风吧、、、\n","categories":["杂谈"],"tags":["杂谈"]},{"title":"恭喜EDG！恭喜cn瓦！","url":"/2024/08/25/%E6%81%AD%E5%96%9CEDG%EF%BC%81%E6%81%AD%E5%96%9Ccn%E7%93%A6%EF%BC%81/","content":"EDG这个冠军的含金量真是无敌的。cn赛区的队伍两支在小组赛垫底回家，一支倒在八强的内战中，整个赛区剩下EDG一根赛区独苗。然后EDG在最不被人看好的时候打满两个BO3，连斩两支美洲的队伍，决赛面对青春风暴硬是杀出一条血路，踩着欧美人拿下fps项目的冠军，最重要的是甚至还是全华班。这放爽文里都是高光时刻的历程让EDG在现实里打出来了，真是完全复刻冰岛+仁川，尤其是康康，无数次拯救队伍，今年的他就是世界最佳选手，只要瓦这游戏正常发展个四五年不暴似，凭康康这次冠军赛的表现，就已经预订了cn电竞的传奇选手称号。\n看了一下午的总决赛，以后还是要少看，太惊险刺激了，心脏受不了。\n","categories":["杂谈"],"tags":["杂谈","游戏"]},{"title":"快手实习总结","url":"/2025/04/28/%E5%BF%AB%E6%89%8B%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"快手实习总结实习氛围快手作为我实习的第一个大厂，周围的同事还是比较友好的，有不会的去问大家也会耐心地给我解答，平时还是有比较充裕的学习时间，大家加班也不是太严重，我觉得还是相当不错的，基本晚上8点就能走，平时也有很多的大的小的活动可以参加，个人感觉还是很不错的。\n技术成长主要的学习成长在于技术视野的成长和学习node和babel，还有就是开发能力的提升和用cursor来为开发提速，平时看一些内部文档，虽然有很多的专业名词，但是还是能学到不少东西的。\n其他的话很多一部分是学到了一些大厂开发的大致流程，并且有一定程度上的了解，但是了解到不同的厂之间可能有一些微妙的区别，这个之后再辨析吧，很幸运的也是面试到了美团的转正实习，希望下一段美团的实习能够获得更大的提升吧。\n","categories":["杂谈"],"tags":["杂谈","实习"]},{"title":"算法笔记","url":"/2024/11/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","content":"二叉树涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。\n求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。\n求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。\n合并二叉树：和一个二叉树逻辑差不多，递归函数传俩值，分别判断两节点；二叉搜索树：重点是使用中序遍历存一个有序数组，之后数组操作；也可用全搜索的形式，来在递归过程中进行更新；\nvar getMinimumDifference = function (root) &#123;    let res = Infinity    let preNode = null    // 中序遍历    const inorder = (node) =&gt; &#123;        if (!node) return        inorder(node.left)        // 更新res        if (preNode) &#123;            res = Math.min(res, node.val - preNode.val)        &#125;        // 记录前一个节点                 preNode = node        inorder(node.right)    &#125;    inorder(root)    return res&#125;\n","categories":["算法"],"tags":["笔记","算法"]},{"title":"有关在项目实践中AI的使用方案","url":"/2025/12/01/%E6%9C%89%E5%85%B3%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E4%B8%ADAI%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88/","content":"引言最近在开发一个学校项目的过程中，我高强度依赖了 Claude Code 进行编程辅助。这段经历给我带来了深刻的启示：虽然 AI 的编码速度惊人，但其生成的代码片段大多停留在 POC（Proof of Concept，概念验证）级别，距离生产环境或商业化的质量标准还有相当大的差距。\n更令人警惕的是，如果缺乏有效的人工干预和质量控制，这些看似”可用”的代码在经历几轮迭代后，极易演变成难以维护的”技术债务”——也就是我们常说的”屎山代码”。这促使我深入思考：究竟如何才能在享受 AI 带来的效率提升的同时，确保代码质量不失控？\n为什么 AI 无法”一键生成”？这个问题成了我思考的起点。从纯粹的编码效率来看，AI 无疑是碾压级的存在——几乎没有程序员的打字速度能与 AI 的生成速度相提并论。然而，一个看似矛盾的现象摆在我们面前：为什么如此强大的 AI，却难以一次性输出高质量的、生产就绪的代码呢？\n经过反复实践和深度思考，我识别出了几个关键的制约因素：\n❌ LLM 智力不足？这个原因基本可以排除。现在的顶级大模型在代码领域已经达到了中高级工程师的水平，无论是算法实现还是语法规范，都展现出了相当强的能力。\n🔴 上下文信息缺失这才是核心瓶颈所在。AI 缺乏对项目的全局认知，具体表现在：\n\n无法理解隐含的业务逻辑和领域知识\n对项目的历史决策背景和演进路径一无所知\n不清楚团队的编码规范和架构约定\n难以感知代码库中已有的设计模式和最佳实践\n\n这些”隐性知识”恰恰是区分”能跑的代码”和”优秀的代码”的关键所在。\n🟡 上下文信息不精确当 AI 基于不精确或不完整的信息进行自主决策时，很容易产生一种特殊的错误——“智能错误”：代码看起来逻辑通顺、语法正确，但实际行为却与预期不符。这类错误往往比明显的 bug 更难排查，因为它们隐藏在看似合理的实现细节中。\n工程化解决方案既然找到了问题的根源，接下来就是如何通过工程化手段来系统化地解决这些问题。根据目前业界的实践探索，我认为大致可以分为两条路径：\n路径一：迭代式开发引导 AI 进行多轮自我优化和迭代，通过不断的反馈循环提升代码质量。\n在这个过程中，要求你一定要有一个持续性迭代的产品文档，不然需求的熵增会导致难以维护的后果。\n路径二：约束式开发通过明确的规则和流程，让 AI 在可控的范围内执行任务，减少意外行为。\n\n渐进式提示词工程根据 Anthropic 官方的实践建议，可以通过 Skills 技术实现渐进式提示词（Progressive Prompting）。这种方法的核心思想非常直观：将复杂的任务拆解为多个简单步骤，每一步都有明确的输入和输出规范。\n✨ 核心优势\n减少幻觉：大幅降低因单次提示词过长而产生的模型幻觉问题\n提升精度：提高每一步执行的精准度和可控性\n便于调试：当出现问题时，可以快速定位到具体的步骤\n模块复用：可以将验证过的提示词片段打包成模块，在不同项目中复用\n渐进增强：可以从简单版本开始，逐步增加复杂度，降低整体风险\n\n💡 实践建议在实际应用中，你可以这样设计渐进式提示词：\n\n第一步：让 AI 理解需求和上下文（不要急于写代码）\n第二步：让 AI 设计整体架构和接口定义\n第三步：让 AI 实现具体功能模块\n第四步：让 AI 进行代码审查和优化建议\n第五步：让 AI 编写测试用例和文档\n\n每一步的输出都成为下一步的输入，形成一个良性的迭代循环。\n\n工作流编排工具除了渐进式提示词，业界还涌现了许多优秀的工作流编排工具，如 n8n、Dify、LangFlow 等。这些工具提供了可视化的编排界面，让开发者可以像”搭积木”一样构建复杂的 AI 应用。\n🎯 核心价值\n\n\n价值维度\n具体表现\n\n\n\n流程可视化\n将抽象的 AI 调用过程转化为直观的流程图，便于理解和沟通\n\n\n任务拆解\n将复杂需求拆解为多个原子化操作，每个操作职责单一\n\n\n精确控制\n每个步骤的输入输出都可以严格定义和验证，减少意外\n\n\n团队协作\n可视化的流程更容易在团队中分享、维护和传承\n\n\n版本管理\n可以对工作流进行版本控制，追踪每次变更的影响\n\n\n🔧 选择建议\nn8n：适合需要集成多种第三方服务的场景，生态丰富\nDify：专注于 LLM 应用开发，提供了很好的 prompt 管理能力\nLangFlow：如果项目基于 LangChain，这是一个自然的选择\n\n选择工具时，建议从团队的技术栈、学习成本和长期维护成本三个维度综合考虑。\n总结与展望通过前面的分析，我们可以得出一个明确的结论：AI 辅助编程绝不是”一键生成”的魔法棒，而是需要通过精心设计的工程化手段来引导和约束的生产力工具。\n渐进式提示词和工作流编排代表了当前两个重要的发展方向，它们都在尝试解决同一个核心问题：\n\n如何让 AI 在保持高效率的同时，输出高质量的、可维护的代码？\n\n\n💼 我的实践建议基于这段时间的摸索和实践，我想分享几个具体的建议：\n1. 调整心态期望\n✅ 接受 AI 生成的是 POC 级别的代码，而非完美的生产代码\n✅ 把 AI 当作”思路启发器“和”初稿生成器“，而非”全栈替代者“\n❌ 不要期望一次提示就能得到生产就绪的代码\n\n2. 采用增量迭代\n将大任务拆解为小步骤，逐步完善而非一步到位\n每次迭代都明确一个具体目标（如：先跑通，再优化，最后重构）\n保持频繁的人工审查和反馈循环\n\n3. 建立规范体系\n制定清晰的编码规范和 AI 使用指南\n建立 AI 生成代码的审查流程（Checklist）\n记录有效的提示词模板，形成团队知识库\n\n4. 保持持续学习\n关注最新的 AI 工程化实践和工具\n定期复盘和优化自己的 AI 工作流\n与社区分享经验，学习他人的最佳实践\n\n\n🎯 结语AI 是强大的生产力工具，但它更像是一个”超级实习生“——需要明确的需求、充分的上下文和持续的指导，才能真正发挥价值。\n正如我们不会指望一个实习生第一天就产出完美的代码一样，我们也不应该对 AI 抱有不切实际的期望。相反，我们应该学会如何与 AI 协作：既利用它的速度和广度，又保持人类的判断力和深度思考能力。\n这或许就是 AI 时代程序员的核心竞争力：不是被 AI 替代，而是学会驾驭 AI，让它成为我们手中最锋利的武器。\n","categories":["AI"],"tags":["AI"]}]